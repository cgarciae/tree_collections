import typing as tp

K = tp.TypeVar("K")
V = tp.TypeVar("V")

class PyBTreeMap(tp.Generic[K, V]):
  def __init__(
      self, other: tp.Union[tp.Mapping[K, V], tp.Iterable[tp.Tuple[K, V]], None] = None
  ) -> None: ...
  def insert(self, key: K, value: V) -> tp.Optional[V]: ...
  def get(self, key: K) -> tp.Optional[V]: ...
  def remove(self, key: K) -> tp.Optional[V]: ...
  def contains_key(self, key: object) -> bool: ...
  def nth(self, n: int) -> tp.Optional[tuple[K, V]]: ...
  # fn len(&self) -> usize
  def len(self) -> int: ...
  # fn is_empty(&self) -> bool
  def is_empty(self) -> bool: ...
  # fn clear(&mut self)
  def clear(self) -> None: ...
  # fn keys(slf: PyRef<'_, Self>) -> PyBTreeMapKeys
  def keys(self) -> tp.KeysView[K]: ...
  # fn values(slf: PyRef<'_, Self>) -> PyBTreeMapValues
  def values(self) -> tp.ValuesView[V]: ...
  # fn items(slf: PyRef<'_, Self>) -> PyBTreeMapIter
  def items(self) -> tp.ItemsView[K, V]: ...

class PyBTreeSet(tp.Generic[K]):

  # pub fn new(input: Option<PyObject>, py: Python) -> PyResult<Self>
  def __init__(self, input: tp.Optional[tp.Iterable[K]] = None) -> None: ...
  # pub fn insert(mut slf: PyRefMut<'_, Self>, key: PyObject) -> PyResult<bool>
  def insert(self, key: K) -> bool: ...
  # pub fn get(slf: PyRef<'_, Self>, key: PyObject) -> PyResult<Option<PyObject>>
  def get(self, key: K) -> tp.Optional[K]: ...
  # pub fn remove(mut slf: PyRefMut<'_, Self>, key: PyObject) -> PyResult<bool>
  def remove(self, key: K) -> bool: ...
  # pub fn contains(slf: PyRef<'_, Self>, key: PyObject) -> PyResult<bool>
  def contains(self, key: object) -> bool: ...
  # pub fn nth(slf: PyRef<'_, Self>, n: i64) -> PyResult<Option<PyObject>>
  def nth(self, n: int) -> tp.Optional[K]: ...
  # pub fn len(&self) -> usize
  def len(self) -> int: ...
  # pub fn is_empty(&self) -> bool
  def is_empty(self) -> bool: ...
  # pub fn clear(&mut self)
  def clear(self) -> None: ...
  # pub fn iter(slf: PyRef<'_, Self>) -> PyBTreeSetIter
  def iter(self) -> tp.Iterator[K]: ...

class PyBTreeSeq(tp.Generic[K]):

  # pub fn new(input: Option<PyObject>, py: Python) -> PyResult<Self>
  def __init__(self, input: tp.Optional[tp.Iterable[K]] = None) -> None: ...
  # pub fn insert(mut slf: PyRefMut<'_, Self>, key: PyObject) -> PyResult<bool>
  def insert(self, key: K) -> bool: ...
  # pub fn get(slf: PyRef<'_, Self>, key: PyObject) -> PyResult<Option<PyObject>>
  def get(self, key: K) -> tp.Optional[K]: ...
  # pub fn remove(mut slf: PyRefMut<'_, Self>, key: PyObject) -> PyResult<bool>
  def remove(self, key: K) -> bool: ...
  # pub fn contains(slf: PyRef<'_, Self>, key: PyObject) -> PyResult<bool>
  def contains(self, key: object) -> bool: ...
  # pub fn nth(slf: PyRef<'_, Self>, n: i64) -> PyResult<Option<PyObject>>
  def nth(self, n: int) -> tp.Optional[K]: ...
  # pub fn len(&self) -> usize
  def len(self) -> int: ...
  # pub fn is_empty(&self) -> bool
  def is_empty(self) -> bool: ...
  # pub fn clear(&mut self)
  def clear(self) -> None: ...
  # pub fn iter(slf: PyRef<'_, Self>) -> PyBTreeSetIter
  def iter(self) -> tp.Iterator[K]: ...
